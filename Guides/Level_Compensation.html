<!doctype html><html lang='en'><head><title>Level Compensation when Mixing and Panning | SuperCollider 3.14.0-rc1 Help</title>
<link rel='stylesheet' href='./../static/scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../static/codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../static/editor.css' type='text/css' />
<link rel='stylesheet' id='scdoc-theme' href='./../static/themes/default.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<link rel='stylesheet' href='./../static/lib/katex/katex.min.css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../static/lib/jquery.min.js'></script>
<script src='./../static/lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../static/lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script defer src='./../static/lib/katex/katex.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'Level Compensation when Mixing and Panning';
var scdoc_sc_version = '3.14.0-rc1';
</script>
<script src='./../static/scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../frontend.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>Level Compensation when Mixing and Panning:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#Considerations'>Considerations</a></li>
<ul class='toc'><li class='toc2'><a href='#Mixing%20M%20channels%20to%201'>Mixing M channels to 1</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Panning%201%20channel%20to%202'>Panning 1 channel to 2</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Panning%201%20channel%20to%20N'>Panning 1 channel to N</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Mix/Panning%20M%20to%202%20channels'>Mix/Panning M to 2 channels</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Mix/Panning%20M%20channels%20to%20N'>Mix/Panning M channels to N</a></li>
<ul class='toc'></ul></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Guides</span>
 | <span id='categories'><a href='./../Browse.html#Multichannel'>Multichannel</a> | <a href='./../Browse.html#Mixing'>Mixing</a> | <a href='./../Browse.html#Panning'>Panning</a></span>
</div><h1>Level Compensation when Mixing and Panning</h1>
<div id='summary'>Balancing Levels when Mixing and Panning in SC</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Classes/Pan2.html">Pan2</a>, <a href="./../Classes/PanAz.html">PanAz</a>, <a href="./../Classes/Splay.html">Splay</a>, <a href="./../Classes/SplayAz.html">SplayAz</a>, <a href="./../Classes/LevelComp.html">LevelComp</a></div>
</div>
<h2><a class='anchor' name='Considerations'>Considerations</a></h2>

<p><a href="./../Guides/Multichannel-Expansion.html">Multichannel Expansion</a> is one of the key features in SuperCollider, making it easy to explore complex polyphonic synthesis and spatialisation. Mixing and panning these signals usually involves going from a number of input channels to a different number of output channels, and for adapting the signal amplitude levels meaningfully, there are two aspects to consider:
<p><strong>1. Technical safety: What will be the maximum amplitude of the new signals? In the worst case, can they clip the audio hardware (by going above +-1.0)?</strong>
<p><strong>2. Perceived loudness: How loud should the new signals it be, relative to others present?</strong>
<p>To balance these aspects, it helps to know more about the signals to be mixed/panned. Most UGens in SC produce a signal amplitude of 1.0, so we will use that value for the discussion here.
<p><strong>Degree of Phase Correlation:</strong> How likely is it that the momentary peaks of the individual signals will line up in time? The two border cases are fully <strong>in-phase:</strong> the same signal on all channels, so the peaks will always line up, and fully <strong>random phase:</strong> different noise signals on all channels, where the peaks will be statistically very unlikely to ever line up. Most musical signals are somewhere between these extremes, i.e. phase-correlated to some degree.
<p><strong>Equal Amplitude Compensation</strong> is the safe bet for highly correlated signals: divide the sum of the number of channels; <strong>Equal Power Compensation</strong> is commonly used for weakly correlated signals, as it keeps the acoustic energy constant by dividing the sum through the square root of the number of channels. As most musical signals are somewhere between the extremes, it makes sense to consider and test for the specific case whenever in doubt.
<p>In the acoustics literature, this level compensation factor is called the p-value [1], and it can be generalized as follows:<div class='codeMirrorContainer'><textarea class='editor'>~levelCompFactor = { |numChans=2, p_value=1|
    numChans ** p_value.clip(0, 1).neg
};
~levelCompFactor.value(2, 1); // equal amplitude, multiply by 1/n
~levelCompFactor.value(2, 0.5); // equal power, mul by square root of 1/n
~levelCompFactor.value(2, 0); // keep full level, no level scaling</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>

<p>Here are some examples for the common cases of Mixing and Panning.<h3><a class='anchor' name='Mixing%20M%20channels%20to%201'>Mixing M channels to 1</a></h3>

<p>Mixing down to mono is the simplest case to show the different approaches to level compensation. UGens or functions for this are <a href="./../Classes/Mix.html">Mix</a>, <code>sum</code>, <code>mean</code>.<div class='codeMirrorContainer'><textarea class='editor'>s.meter; s.scope;

n = 10;
// 10 chans to 1, fully coherent in-phase signals:
{ (SinOsc.ar ! n) }.plot;
{ (SinOsc.ar ! n).sum }.plot;       // sum : +-10
// equal amplitude: divide by number of channels -&gt; peak 1
{ (SinOsc.ar ! n).sum / n }.plot;   // sum
{ Mix.ar(SinOsc.ar ! n) / n }.plot; // same with Mix.ar
{ (SinOsc.ar ! n).mean }.plot;      // mean directly divides by n!

// 10 chans to 1, quasi coherent with 100Hz shared root:
{ SinOsc.ar((1..n) * 100, 0.5pi) }.plot(0.05);

// because peaks coincide exactly (with 0.5pi phase shift),
// we have to divide by n to stay within +-1:
{ SinOsc.ar((1..n) * 100, 0.5pi).sum / n }.plot(0.05);
{ SinOsc.ar((1..n) * 100, 0.5pi).sum / n }.play;

// signals are less coherent with random freqs in the same range
{ SinOsc.ar({ rrand(100.0, 1000.0).postln }! n, 0.5pi).sum / n }.play;

// very random-phase signals
{ PinkNoise.ar(1 ! n) }.play;

// compare single channel ...
{ PinkNoise.ar }.play;

// with mixdown of n to 1 with equal power compensation:
// volume is quite similar, can peak, but will very rarely
{ PinkNoise.ar({ 1 } ! n).sum / n.sqrt }.play;</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>
<h3><a class='anchor' name='Panning%201%20channel%20to%202'>Panning 1 channel to 2</a></h3>

<p><a href="./../Classes/Pan2.html">Pan2</a> uses equal power panning: when panned to the center, both signals are at 0.7, or -3 dB<div class='codeMirrorContainer'><textarea class='editor'>{ Pan2.ar(DC.ar(1), Line.kr(-1, 1, 0.1)) }.plot(0.1);
// loudness seems constant when panning
{ Pan2.ar(PinkNoise.ar(0.2), SinOsc.kr(0.3)) }.play;</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>

<p><a href="./../Classes/LinPan2.html">LinPan2</a> uses equal amplitude panning: in the center, both signals are at 0.5.<div class='codeMirrorContainer'><textarea class='editor'>{ LinPan2.ar(DC.ar(1), Line.kr(-1, 1, 0.1)) }.plot(0.1);
// loudness seems to drop slightly when in the center
{ LinPan2.ar(PinkNoise.ar(0.2), SinOsc.kr(0.3)) }.play;</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>
<h3><a class='anchor' name='Panning%201%20channel%20to%20N'>Panning 1 channel to N</a></h3>

<p><a href="./../Classes/PanAz.html">PanAz</a> uses equal power panning, so with a default width of 2, it keeps the energy constant, like <a href="./../Classes/Pan2.html">Pan2</a>.<div class='codeMirrorContainer'><textarea class='editor'>{ PanAz.ar(4, DC.ar(1), Line.kr(-1, 1, 0.1), orientation: 0) }.plot(0.1);

// with larger width, the overlaps get bigger, and the overall energy rises,
// so one may want to compensate amplitude for larger width
{ PanAz.ar(4, DC.ar(1), Line.kr(-1, 1, 0.1), width: 4, orientation: 0) }.plot(0.1);</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>
<h3><a class='anchor' name='Mix/Panning%20M%20to%202%20channels'>Mix/Panning M to 2 channels</a></h3>

<p><a href="./../Classes/Splay.html">Splay</a> mixes an array of input channels down to stereo using <a href="./../Classes/Pan2.html">Pan2</a>, and it has 3 options for level compensation:<div class='codeMirrorContainer'><textarea class='editor'>s.meter; s.scope;

// levelComp defaults to true, which is equal power -
// this is kept this way for backwards compatibility.
{ Splay.ar(Saw.ar([20, 30, 50]), 1, levelComp: true) }.scope;
// levelComp can be turned off to set level otherwise:
{ Splay.ar(Saw.ar([20, 30, 50]), level: 0.6, levelComp: false) }.scope;

// levelComp can be a number between 0.0 -&gt; no comp,
// and 1.0 -&gt; equal amplitude comp, with 0.5 being equal power,
// which allows fine/tuning by hand via the exponent:
{ Splay.ar(Saw.ar([100, 150, 250]), levelComp: 0.5) }.scope;

// When setting spread low, levels and peaks will go up;
// the worst case is panning all inputs to a single channel:
{ Splay.ar(Saw.ar([100, 150, 250]), spread: 0, center: 1, levelComp: 0.5) }.scope;</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>

<p>Note that this levelComp factor scales with the number of channels, so tuning to somewhere between 0.5 and 1.0 should work well when experimenting with changing numbers of channels.<h3><a class='anchor' name='Mix/Panning%20M%20channels%20to%20N'>Mix/Panning M channels to N</a></h3>

<p><a href="./../Classes/SplayAz.html">SplayAz</a> mixes an array of M input channels to N outputs using <a href="./../Classes/PanAz.html">PanAz</a>; it has 3 options for level compensation:<div class='codeMirrorContainer'><textarea class='editor'>s.meter; s.scope;

n = 10;
// levelComp defaults to true, which is equal power:
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), 1, levelComp: true) }.scope;
// levelComp can be off to compensate by hand/ear:
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), level: (1/n).sqrt, levelComp: false) }.scope;

// as in Splay, levelComp can be a number between 0.0 -&gt; no comp,
// and 1.0 -&gt; equal amplitude comp, with 0.5 being equal power.
// This allows fine-tuning by hand via the levelComp exponent:
// requires PR on SplayAz
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), level: 0.5, levelComp: 0.7) }.scope;

// When setting spread low, levels on single channel(s) go up:
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), level: 0.5, spread: 0, orientation: 0) }.scope;

// Worst case: all panned to same out channel go up:
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), level: 0.5) }.scope;

// When width values are high, the overall output level also rises,
// because each channel is directed to more channels:
{ SplayAz.ar(4, Saw.ar({ exprand(100, 500) }! n), level: 0.5, width: 4) }.scope;</textarea>
<button class='copy-button' aria-label='Copy code'><span class='copy-ico'>⧉</span><span class='check-ico'>✔</span></button></div>

<p>[1] Laitinen, Mikko-Ville, et al. "Gain normalization in amplitude panning as a function of frequency and room reverberance." Audio Engineering Society Conference: 55th International Conference: Spatial Audio. Audio Engineering Society, 2014.<div class='doclink'>helpfile source: <a href='https://github.com/supercollider/supercollider/tree/3.14/HelpSource/Guides/Level_Compensation.schelp'>https://github.com/supercollider/supercollider/tree/3.14/HelpSource/Guides/Level_Compensation.schelp</a><br>link::Guides/Level_Compensation::<br></div></div><script src='./../static/editor.js' type='text/javascript'></script>
</body></html>